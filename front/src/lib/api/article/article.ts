/**
 * Generated by orval v7.5.0 üç∫
 * Do not edit manually.
 * Hello API Platform
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query'
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query'
import type {
  ApiArticlesGetCollection200,
  ApiArticlesGetCollectionParams,
  Article,
  ArticleJsonld,
} from '.././models'
import { customInstance } from '.././axios-instance'
import type { ErrorType } from '.././axios-instance'

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> =
  (<T>() => T extends X ? 1 : 2) extends <T>() => T extends Y ? 1 : 2 ? A : B

type WritableKeys<T> = {
  [P in keyof T]-?: IfEquals<{ [Q in P]: T[P] }, { -readonly [Q in P]: T[P] }, P>
}[keyof T]

type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void
  ? I
  : never
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never

type Writable<T> = Pick<T, WritableKeys<T>>
type NonReadonly<T> = [T] extends [UnionToIntersection<T>]
  ? {
      [P in keyof Writable<T>]: T[P] extends object ? NonReadonly<NonNullable<T[P]>> : T[P]
    }
  : DistributeReadOnlyOverUnions<T>

type SecondParameter<T extends (...args: any) => any> = Parameters<T>[1]

/**
 * Retrieves the collection of Article resources.
 * @summary Retrieves the collection of Article resources.
 */
export const apiArticlesGetCollection = (
  params?: ApiArticlesGetCollectionParams,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ApiArticlesGetCollection200>(
    { url: `https://myfitness.api.localhost/api/articles`, method: 'GET', params, signal },
    options,
  )
}

export const getApiArticlesGetCollectionQueryKey = (params?: ApiArticlesGetCollectionParams) => {
  return [`https://myfitness.api.localhost/api/articles`, ...(params ? [params] : [])] as const
}

export const getApiArticlesGetCollectionQueryOptions = <
  TData = Awaited<ReturnType<typeof apiArticlesGetCollection>>,
  TError = ErrorType<unknown>,
>(
  params?: ApiArticlesGetCollectionParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiArticlesGetCollection>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getApiArticlesGetCollectionQueryKey(params)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof apiArticlesGetCollection>>> = ({
    signal,
  }) => apiArticlesGetCollection(params, requestOptions, signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof apiArticlesGetCollection>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiArticlesGetCollectionQueryResult = NonNullable<
  Awaited<ReturnType<typeof apiArticlesGetCollection>>
>
export type ApiArticlesGetCollectionQueryError = ErrorType<unknown>

export function useApiArticlesGetCollection<
  TData = Awaited<ReturnType<typeof apiArticlesGetCollection>>,
  TError = ErrorType<unknown>,
>(
  params: undefined | ApiArticlesGetCollectionParams,
  options: {
    query: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiArticlesGetCollection>>, TError, TData>
    > &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiArticlesGetCollection>>,
          TError,
          Awaited<ReturnType<typeof apiArticlesGetCollection>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiArticlesGetCollection<
  TData = Awaited<ReturnType<typeof apiArticlesGetCollection>>,
  TError = ErrorType<unknown>,
>(
  params?: ApiArticlesGetCollectionParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiArticlesGetCollection>>, TError, TData>
    > &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiArticlesGetCollection>>,
          TError,
          Awaited<ReturnType<typeof apiArticlesGetCollection>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiArticlesGetCollection<
  TData = Awaited<ReturnType<typeof apiArticlesGetCollection>>,
  TError = ErrorType<unknown>,
>(
  params?: ApiArticlesGetCollectionParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiArticlesGetCollection>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves the collection of Article resources.
 */

export function useApiArticlesGetCollection<
  TData = Awaited<ReturnType<typeof apiArticlesGetCollection>>,
  TError = ErrorType<unknown>,
>(
  params?: ApiArticlesGetCollectionParams,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof apiArticlesGetCollection>>, TError, TData>
    >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getApiArticlesGetCollectionQueryOptions(params, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Creates a Article resource.
 * @summary Creates a Article resource.
 */
export const apiArticlesPost = (
  articleJsonld: NonReadonly<ArticleJsonld>,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ArticleJsonld>(
    {
      url: `https://myfitness.api.localhost/api/articles`,
      method: 'POST',
      headers: { 'Content-Type': 'application/ld+json' },
      data: articleJsonld,
      signal,
    },
    options,
  )
}

export const getApiArticlesPostMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof apiArticlesPost>>,
    TError,
    { data: NonReadonly<ArticleJsonld> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof apiArticlesPost>>,
  TError,
  { data: NonReadonly<ArticleJsonld> },
  TContext
> => {
  const mutationKey = ['apiArticlesPost']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof apiArticlesPost>>,
    { data: NonReadonly<ArticleJsonld> }
  > = (props) => {
    const { data } = props ?? {}

    return apiArticlesPost(data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ApiArticlesPostMutationResult = NonNullable<Awaited<ReturnType<typeof apiArticlesPost>>>
export type ApiArticlesPostMutationBody = NonReadonly<ArticleJsonld>
export type ApiArticlesPostMutationError = ErrorType<void>

/**
 * @summary Creates a Article resource.
 */
export const useApiArticlesPost = <TError = ErrorType<void>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof apiArticlesPost>>,
    TError,
    { data: NonReadonly<ArticleJsonld> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof apiArticlesPost>>,
  TError,
  { data: NonReadonly<ArticleJsonld> },
  TContext
> => {
  const mutationOptions = getApiArticlesPostMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Retrieves a Article resource.
 * @summary Retrieves a Article resource.
 */
export const apiArticlesIdGet = (
  id: string,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<ArticleJsonld>(
    { url: `https://myfitness.api.localhost/api/articles/${id}`, method: 'GET', signal },
    options,
  )
}

export const getApiArticlesIdGetQueryKey = (id: string) => {
  return [`https://myfitness.api.localhost/api/articles/${id}`] as const
}

export const getApiArticlesIdGetQueryOptions = <
  TData = Awaited<ReturnType<typeof apiArticlesIdGet>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof apiArticlesIdGet>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {}

  const queryKey = queryOptions?.queryKey ?? getApiArticlesIdGetQueryKey(id)

  const queryFn: QueryFunction<Awaited<ReturnType<typeof apiArticlesIdGet>>> = ({ signal }) =>
    apiArticlesIdGet(id, requestOptions, signal)

  return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof apiArticlesIdGet>>,
    TError,
    TData
  > & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ApiArticlesIdGetQueryResult = NonNullable<Awaited<ReturnType<typeof apiArticlesIdGet>>>
export type ApiArticlesIdGetQueryError = ErrorType<void>

export function useApiArticlesIdGet<
  TData = Awaited<ReturnType<typeof apiArticlesIdGet>>,
  TError = ErrorType<void>,
>(
  id: string,
  options: {
    query: Partial<UseQueryOptions<Awaited<ReturnType<typeof apiArticlesIdGet>>, TError, TData>> &
      Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiArticlesIdGet>>,
          TError,
          Awaited<ReturnType<typeof apiArticlesIdGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiArticlesIdGet<
  TData = Awaited<ReturnType<typeof apiArticlesIdGet>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof apiArticlesIdGet>>, TError, TData>> &
      Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof apiArticlesIdGet>>,
          TError,
          Awaited<ReturnType<typeof apiArticlesIdGet>>
        >,
        'initialData'
      >
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useApiArticlesIdGet<
  TData = Awaited<ReturnType<typeof apiArticlesIdGet>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof apiArticlesIdGet>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieves a Article resource.
 */

export function useApiArticlesIdGet<
  TData = Awaited<ReturnType<typeof apiArticlesIdGet>>,
  TError = ErrorType<void>,
>(
  id: string,
  options?: {
    query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof apiArticlesIdGet>>, TError, TData>>
    request?: SecondParameter<typeof customInstance>
  },
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
  const queryOptions = getApiArticlesIdGetQueryOptions(id, options)

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>
  }

  query.queryKey = queryOptions.queryKey

  return query
}

/**
 * Removes the Article resource.
 * @summary Removes the Article resource.
 */
export const apiArticlesIdDelete = (
  id: string,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<void>(
    { url: `https://myfitness.api.localhost/api/articles/${id}`, method: 'DELETE' },
    options,
  )
}

export const getApiArticlesIdDeleteMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof apiArticlesIdDelete>>,
    TError,
    { id: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof apiArticlesIdDelete>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationKey = ['apiArticlesIdDelete']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof apiArticlesIdDelete>>,
    { id: string }
  > = (props) => {
    const { id } = props ?? {}

    return apiArticlesIdDelete(id, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ApiArticlesIdDeleteMutationResult = NonNullable<
  Awaited<ReturnType<typeof apiArticlesIdDelete>>
>

export type ApiArticlesIdDeleteMutationError = ErrorType<void>

/**
 * @summary Removes the Article resource.
 */
export const useApiArticlesIdDelete = <TError = ErrorType<void>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof apiArticlesIdDelete>>,
    TError,
    { id: string },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof apiArticlesIdDelete>>,
  TError,
  { id: string },
  TContext
> => {
  const mutationOptions = getApiArticlesIdDeleteMutationOptions(options)

  return useMutation(mutationOptions)
}
/**
 * Updates the Article resource.
 * @summary Updates the Article resource.
 */
export const apiArticlesIdPatch = (
  id: string,
  article: NonReadonly<Article>,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<ArticleJsonld>(
    {
      url: `https://myfitness.api.localhost/api/articles/${id}`,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/merge-patch+json' },
      data: article,
    },
    options,
  )
}

export const getApiArticlesIdPatchMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof apiArticlesIdPatch>>,
    TError,
    { id: string; data: NonReadonly<Article> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationOptions<
  Awaited<ReturnType<typeof apiArticlesIdPatch>>,
  TError,
  { id: string; data: NonReadonly<Article> },
  TContext
> => {
  const mutationKey = ['apiArticlesIdPatch']
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined }

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof apiArticlesIdPatch>>,
    { id: string; data: NonReadonly<Article> }
  > = (props) => {
    const { id, data } = props ?? {}

    return apiArticlesIdPatch(id, data, requestOptions)
  }

  return { mutationFn, ...mutationOptions }
}

export type ApiArticlesIdPatchMutationResult = NonNullable<
  Awaited<ReturnType<typeof apiArticlesIdPatch>>
>
export type ApiArticlesIdPatchMutationBody = NonReadonly<Article>
export type ApiArticlesIdPatchMutationError = ErrorType<void>

/**
 * @summary Updates the Article resource.
 */
export const useApiArticlesIdPatch = <TError = ErrorType<void>, TContext = unknown>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof apiArticlesIdPatch>>,
    TError,
    { id: string; data: NonReadonly<Article> },
    TContext
  >
  request?: SecondParameter<typeof customInstance>
}): UseMutationResult<
  Awaited<ReturnType<typeof apiArticlesIdPatch>>,
  TError,
  { id: string; data: NonReadonly<Article> },
  TContext
> => {
  const mutationOptions = getApiArticlesIdPatchMutationOptions(options)

  return useMutation(mutationOptions)
}
